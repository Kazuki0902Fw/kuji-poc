// Code generated by BobGen mysql v0.40.2. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var Preload = getPreloaders()

type preloaders struct {
	Contact                       contactPreloader
	CreditCard                    creditCardPreloader
	IntellectualProperty          intellectualPropertyPreloader
	IntellectualPropertyCategory  intellectualPropertyCategoryPreloader
	IntellectualPropertyRankGroup intellectualPropertyRankGroupPreloader
	PurchaseHistory               purchaseHistoryPreloader
	PurchaseTransaction           purchaseTransactionPreloader
	RefreshToken                  refreshTokenPreloader
	ShippingAddress               shippingAddressPreloader
	User                          userPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		Contact:                       buildContactPreloader(),
		CreditCard:                    buildCreditCardPreloader(),
		IntellectualProperty:          buildIntellectualPropertyPreloader(),
		IntellectualPropertyCategory:  buildIntellectualPropertyCategoryPreloader(),
		IntellectualPropertyRankGroup: buildIntellectualPropertyRankGroupPreloader(),
		PurchaseHistory:               buildPurchaseHistoryPreloader(),
		PurchaseTransaction:           buildPurchaseTransactionPreloader(),
		RefreshToken:                  buildRefreshTokenPreloader(),
		ShippingAddress:               buildShippingAddressPreloader(),
		User:                          buildUserPreloader(),
	}
}

var SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()

type thenLoaders[Q orm.Loadable] struct {
	Contact                       contactThenLoader[Q]
	CreditCard                    creditCardThenLoader[Q]
	IntellectualProperty          intellectualPropertyThenLoader[Q]
	IntellectualPropertyCategory  intellectualPropertyCategoryThenLoader[Q]
	IntellectualPropertyRankGroup intellectualPropertyRankGroupThenLoader[Q]
	PurchaseHistory               purchaseHistoryThenLoader[Q]
	PurchaseTransaction           purchaseTransactionThenLoader[Q]
	RefreshToken                  refreshTokenThenLoader[Q]
	ShippingAddress               shippingAddressThenLoader[Q]
	User                          userThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		Contact:                       buildContactThenLoader[Q](),
		CreditCard:                    buildCreditCardThenLoader[Q](),
		IntellectualProperty:          buildIntellectualPropertyThenLoader[Q](),
		IntellectualPropertyCategory:  buildIntellectualPropertyCategoryThenLoader[Q](),
		IntellectualPropertyRankGroup: buildIntellectualPropertyRankGroupThenLoader[Q](),
		PurchaseHistory:               buildPurchaseHistoryThenLoader[Q](),
		PurchaseTransaction:           buildPurchaseTransactionThenLoader[Q](),
		RefreshToken:                  buildRefreshTokenThenLoader[Q](),
		ShippingAddress:               buildShippingAddressThenLoader[Q](),
		User:                          buildUserThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		}
	}
}
