// Code generated by BobGen mysql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
)

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Contacts                       joinSet[contactJoins[Q]]
	CreditCards                    joinSet[creditCardJoins[Q]]
	IntellectualProperties         joinSet[intellectualPropertyJoins[Q]]
	IntellectualPropertyCategories joinSet[intellectualPropertyCategoryJoins[Q]]
	IntellectualPropertyRankGroups joinSet[intellectualPropertyRankGroupJoins[Q]]
	PurchaseHistories              joinSet[purchaseHistoryJoins[Q]]
	PurchaseTransactions           joinSet[purchaseTransactionJoins[Q]]
	ShippingAddresses              joinSet[shippingAddressJoins[Q]]
	Users                          joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Contacts:                       buildJoinSet[contactJoins[Q]](Contacts.Columns, buildContactJoins),
		CreditCards:                    buildJoinSet[creditCardJoins[Q]](CreditCards.Columns, buildCreditCardJoins),
		IntellectualProperties:         buildJoinSet[intellectualPropertyJoins[Q]](IntellectualProperties.Columns, buildIntellectualPropertyJoins),
		IntellectualPropertyCategories: buildJoinSet[intellectualPropertyCategoryJoins[Q]](IntellectualPropertyCategories.Columns, buildIntellectualPropertyCategoryJoins),
		IntellectualPropertyRankGroups: buildJoinSet[intellectualPropertyRankGroupJoins[Q]](IntellectualPropertyRankGroups.Columns, buildIntellectualPropertyRankGroupJoins),
		PurchaseHistories:              buildJoinSet[purchaseHistoryJoins[Q]](PurchaseHistories.Columns, buildPurchaseHistoryJoins),
		PurchaseTransactions:           buildJoinSet[purchaseTransactionJoins[Q]](PurchaseTransactions.Columns, buildPurchaseTransactionJoins),
		ShippingAddresses:              buildJoinSet[shippingAddressJoins[Q]](ShippingAddresses.Columns, buildShippingAddressJoins),
		Users:                          buildJoinSet[userJoins[Q]](Users.Columns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}
