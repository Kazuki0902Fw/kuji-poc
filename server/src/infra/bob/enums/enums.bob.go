// Code generated by BobGen mysql v0.40.2. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package enums

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for ContactsContactType
const (
	ContactsContactTypeInquiry    ContactsContactType = "inquiry"
	ContactsContactTypeComplaint  ContactsContactType = "complaint"
	ContactsContactTypeSuggestion ContactsContactType = "suggestion"
	ContactsContactTypeOther      ContactsContactType = "other"
)

func AllContactsContactType() []ContactsContactType {
	return []ContactsContactType{
		ContactsContactTypeInquiry,
		ContactsContactTypeComplaint,
		ContactsContactTypeSuggestion,
		ContactsContactTypeOther,
	}
}

type ContactsContactType string

func (e ContactsContactType) String() string {
	return string(e)
}

func (e ContactsContactType) Valid() bool {
	switch e {
	case ContactsContactTypeInquiry,
		ContactsContactTypeComplaint,
		ContactsContactTypeSuggestion,
		ContactsContactTypeOther:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e ContactsContactType) All() []ContactsContactType {
	return AllContactsContactType()
}

func (e ContactsContactType) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *ContactsContactType) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e ContactsContactType) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *ContactsContactType) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e ContactsContactType) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *ContactsContactType) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = ContactsContactType(x)
	case []byte:
		*e = ContactsContactType(x)
	case nil:
		return fmt.Errorf("cannot nil into ContactsContactType")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid ContactsContactType value: %s", *e)
	}

	return nil
}

// Enum values for IntellectualPropertyRankGroupsRank
const (
	IntellectualPropertyRankGroupsRankS IntellectualPropertyRankGroupsRank = "S"
	IntellectualPropertyRankGroupsRankA IntellectualPropertyRankGroupsRank = "A"
	IntellectualPropertyRankGroupsRankB IntellectualPropertyRankGroupsRank = "B"
	IntellectualPropertyRankGroupsRankC IntellectualPropertyRankGroupsRank = "C"
	IntellectualPropertyRankGroupsRankD IntellectualPropertyRankGroupsRank = "D"
	IntellectualPropertyRankGroupsRankE IntellectualPropertyRankGroupsRank = "E"
)

func AllIntellectualPropertyRankGroupsRank() []IntellectualPropertyRankGroupsRank {
	return []IntellectualPropertyRankGroupsRank{
		IntellectualPropertyRankGroupsRankS,
		IntellectualPropertyRankGroupsRankA,
		IntellectualPropertyRankGroupsRankB,
		IntellectualPropertyRankGroupsRankC,
		IntellectualPropertyRankGroupsRankD,
		IntellectualPropertyRankGroupsRankE,
	}
}

type IntellectualPropertyRankGroupsRank string

func (e IntellectualPropertyRankGroupsRank) String() string {
	return string(e)
}

func (e IntellectualPropertyRankGroupsRank) Valid() bool {
	switch e {
	case IntellectualPropertyRankGroupsRankS,
		IntellectualPropertyRankGroupsRankA,
		IntellectualPropertyRankGroupsRankB,
		IntellectualPropertyRankGroupsRankC,
		IntellectualPropertyRankGroupsRankD,
		IntellectualPropertyRankGroupsRankE:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e IntellectualPropertyRankGroupsRank) All() []IntellectualPropertyRankGroupsRank {
	return AllIntellectualPropertyRankGroupsRank()
}

func (e IntellectualPropertyRankGroupsRank) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *IntellectualPropertyRankGroupsRank) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e IntellectualPropertyRankGroupsRank) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *IntellectualPropertyRankGroupsRank) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e IntellectualPropertyRankGroupsRank) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *IntellectualPropertyRankGroupsRank) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = IntellectualPropertyRankGroupsRank(x)
	case []byte:
		*e = IntellectualPropertyRankGroupsRank(x)
	case nil:
		return fmt.Errorf("cannot nil into IntellectualPropertyRankGroupsRank")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid IntellectualPropertyRankGroupsRank value: %s", *e)
	}

	return nil
}

// Enum values for PurchaseTransactionsPaymentMethod
const (
	PurchaseTransactionsPaymentMethodCreditCard   PurchaseTransactionsPaymentMethod = "credit_card"
	PurchaseTransactionsPaymentMethodBankTransfer PurchaseTransactionsPaymentMethod = "bank_transfer"
	PurchaseTransactionsPaymentMethodOther        PurchaseTransactionsPaymentMethod = "other"
)

func AllPurchaseTransactionsPaymentMethod() []PurchaseTransactionsPaymentMethod {
	return []PurchaseTransactionsPaymentMethod{
		PurchaseTransactionsPaymentMethodCreditCard,
		PurchaseTransactionsPaymentMethodBankTransfer,
		PurchaseTransactionsPaymentMethodOther,
	}
}

type PurchaseTransactionsPaymentMethod string

func (e PurchaseTransactionsPaymentMethod) String() string {
	return string(e)
}

func (e PurchaseTransactionsPaymentMethod) Valid() bool {
	switch e {
	case PurchaseTransactionsPaymentMethodCreditCard,
		PurchaseTransactionsPaymentMethodBankTransfer,
		PurchaseTransactionsPaymentMethodOther:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PurchaseTransactionsPaymentMethod) All() []PurchaseTransactionsPaymentMethod {
	return AllPurchaseTransactionsPaymentMethod()
}

func (e PurchaseTransactionsPaymentMethod) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PurchaseTransactionsPaymentMethod) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PurchaseTransactionsPaymentMethod) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PurchaseTransactionsPaymentMethod) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PurchaseTransactionsPaymentMethod) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PurchaseTransactionsPaymentMethod) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PurchaseTransactionsPaymentMethod(x)
	case []byte:
		*e = PurchaseTransactionsPaymentMethod(x)
	case nil:
		return fmt.Errorf("cannot nil into PurchaseTransactionsPaymentMethod")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PurchaseTransactionsPaymentMethod value: %s", *e)
	}

	return nil
}

// Enum values for PurchaseTransactionsStatus
const (
	PurchaseTransactionsStatusPaymentPending PurchaseTransactionsStatus = "payment_pending"
	PurchaseTransactionsStatusPaymentSuccess PurchaseTransactionsStatus = "payment_success"
	PurchaseTransactionsStatusPaymentFailed  PurchaseTransactionsStatus = "payment_failed"
	PurchaseTransactionsStatusDrawSuccess    PurchaseTransactionsStatus = "draw_success"
	PurchaseTransactionsStatusDrawFailed     PurchaseTransactionsStatus = "draw_failed"
)

func AllPurchaseTransactionsStatus() []PurchaseTransactionsStatus {
	return []PurchaseTransactionsStatus{
		PurchaseTransactionsStatusPaymentPending,
		PurchaseTransactionsStatusPaymentSuccess,
		PurchaseTransactionsStatusPaymentFailed,
		PurchaseTransactionsStatusDrawSuccess,
		PurchaseTransactionsStatusDrawFailed,
	}
}

type PurchaseTransactionsStatus string

func (e PurchaseTransactionsStatus) String() string {
	return string(e)
}

func (e PurchaseTransactionsStatus) Valid() bool {
	switch e {
	case PurchaseTransactionsStatusPaymentPending,
		PurchaseTransactionsStatusPaymentSuccess,
		PurchaseTransactionsStatusPaymentFailed,
		PurchaseTransactionsStatusDrawSuccess,
		PurchaseTransactionsStatusDrawFailed:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PurchaseTransactionsStatus) All() []PurchaseTransactionsStatus {
	return AllPurchaseTransactionsStatus()
}

func (e PurchaseTransactionsStatus) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PurchaseTransactionsStatus) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PurchaseTransactionsStatus) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PurchaseTransactionsStatus) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PurchaseTransactionsStatus) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PurchaseTransactionsStatus) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PurchaseTransactionsStatus(x)
	case []byte:
		*e = PurchaseTransactionsStatus(x)
	case nil:
		return fmt.Errorf("cannot nil into PurchaseTransactionsStatus")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PurchaseTransactionsStatus value: %s", *e)
	}

	return nil
}

// Enum values for UsersGender
const (
	UsersGenderMale   UsersGender = "male"
	UsersGenderFemale UsersGender = "female"
)

func AllUsersGender() []UsersGender {
	return []UsersGender{
		UsersGenderMale,
		UsersGenderFemale,
	}
}

type UsersGender string

func (e UsersGender) String() string {
	return string(e)
}

func (e UsersGender) Valid() bool {
	switch e {
	case UsersGenderMale, UsersGenderFemale:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e UsersGender) All() []UsersGender {
	return AllUsersGender()
}

func (e UsersGender) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *UsersGender) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e UsersGender) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *UsersGender) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e UsersGender) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *UsersGender) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = UsersGender(x)
	case []byte:
		*e = UsersGender(x)
	case nil:
		return fmt.Errorf("cannot nil into UsersGender")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid UsersGender value: %s", *e)
	}

	return nil
}
